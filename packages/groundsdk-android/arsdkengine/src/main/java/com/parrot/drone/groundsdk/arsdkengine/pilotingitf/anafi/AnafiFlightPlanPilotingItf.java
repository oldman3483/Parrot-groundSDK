/*
 *     Copyright (C) 2019 Parrot Drones SAS
 *
 *     Redistribution and use in source and binary forms, with or without
 *     modification, are permitted provided that the following conditions
 *     are met:
 *     * Redistributions of source code must retain the above copyright
 *       notice, this list of conditions and the following disclaimer.
 *     * Redistributions in binary form must reproduce the above copyright
 *       notice, this list of conditions and the following disclaimer in
 *       the documentation and/or other materials provided with the
 *       distribution.
 *     * Neither the name of the Parrot Company nor the names
 *       of its contributors may be used to endorse or promote products
 *       derived from this software without specific prior written
 *       permission.
 *
 *     THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 *     "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 *     LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS
 *     FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE
 *     PARROT COMPANY BE LIABLE FOR ANY DIRECT, INDIRECT,
 *     INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,
 *     BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS
 *     OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
 *     AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,
 *     OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT
 *     OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 *     SUCH DAMAGE.
 *
 */

package com.parrot.drone.groundsdk.arsdkengine.pilotingitf.anafi;

import androidx.annotation.NonNull;
import androidx.annotation.Nullable;

import com.parrot.drone.groundsdk.arsdkengine.devicecontroller.PilotingItfActivationController;
import com.parrot.drone.groundsdk.arsdkengine.http.HttpFlightPlanClient;
import com.parrot.drone.groundsdk.arsdkengine.persistence.PersistentStore;
import com.parrot.drone.groundsdk.arsdkengine.persistence.StorageEntry;
import com.parrot.drone.groundsdk.arsdkengine.pilotingitf.ActivablePilotingItfController;
import com.parrot.drone.groundsdk.device.pilotingitf.FlightPlanPilotingItf.ActivationError;
import com.parrot.drone.groundsdk.device.pilotingitf.FlightPlanPilotingItf.UnavailabilityReason;
import com.parrot.drone.groundsdk.device.pilotingitf.FlightPlanPilotingItf.UploadState;
import com.parrot.drone.groundsdk.internal.device.pilotingitf.flightplan.FlightPlanPilotingItfCore;
import com.parrot.drone.groundsdk.internal.http.HttpRequest;
import com.parrot.drone.sdkcore.arsdk.ArsdkFeatureCommon;
import com.parrot.drone.sdkcore.arsdk.ArsdkFeatureCommon.MavlinkstateMavlinkfileplayingstatechangedState;
import com.parrot.drone.sdkcore.arsdk.ArsdkFeatureCommon.MavlinkstateMavlinkfileplayingstatechangedType;
import com.parrot.drone.sdkcore.arsdk.command.ArsdkCommand;
import com.parrot.drone.sdkcore.ulog.ULog;

import java.io.File;

import static com.parrot.drone.groundsdk.arsdkengine.Logging.TAG_FLIGHTPLAN;

/** FlightPlan piloting interface controller for Anafi family drones. */
public class AnafiFlightPlanPilotingItf extends ActivablePilotingItfController {

    /** Key used to access preset and range dictionaries for this piloting interface settings. */
    private static final String SETTINGS_KEY = "flightPlan";

    // preset store bindings

    /** Preferred target preset entry. */
    private static final StorageEntry<Boolean> RETURN_HOME_ON_DISCONNECT_PRESET =
            StorageEntry.ofBoolean("returnHomeOnDisconnect");

    // device specific store bindings

    /** Min altitude range device setting. */
    private static final StorageEntry<Boolean> RETURN_HOME_ON_DISCONNECT_MUTABILITY_SETTING =
            StorageEntry.ofBoolean("returnHomeOnDisconnectMutability");

    /** Piloting interface for which this object is the backend. */
    @NonNull
    private final FlightPlanPilotingItfCore mPilotingItf;

    /** Persists device specific values for this piloting interface, such as settings ranges, supported status. */
    @Nullable
    private final PersistentStore.Dictionary mDeviceDict;

    /** Persists current preset values for this piloting interface. */
    @Nullable
    private PersistentStore.Dictionary mPresetDict;

    /** Return home on disconnect. */
    @Nullable
    private Boolean mReturnHomeOnDisconnect;

    /** Keeps track of flight plan file to upload while waiting for deactivation prior upload. */
    @Nullable
    private File mFlightPlanToUpload;

    /** Uid of the latest uploaded flight plan. Generated by the drone and returned when flight plan is uploaded. */
    @Nullable
    private String mFlightPlanUid;

    /** {@code true} when the drone reports that all conditions to start a Flight Plan hold. */
    private boolean mFlightPlanAvailable;

    /** Whether the flight plan should be started when {@code STOPPED} playing state is received. */
    private boolean mRestart;

    /** Whether the flight plan is currently playing. */
    private boolean mPlaying;

    /** Whether the flight plan is currently stopped. */
    private boolean mStopped;

    /**
     * Constructor.
     *
     * @param activationController activation controller that owns this piloting interface controller
     */
    public AnafiFlightPlanPilotingItf(@NonNull PilotingItfActivationController activationController) {
        super(activationController, false);
        mPresetDict = offlineSettingsEnabled() ? mDeviceController.getPresetDict().getDictionary(SETTINGS_KEY) : null;
        mDeviceDict = offlineSettingsEnabled() ? mDeviceController.getDeviceDict().getDictionary(SETTINGS_KEY) : null;
        mPilotingItf = new FlightPlanPilotingItfCore(mComponentStore, new Backend());
        loadPersistedData();
        if (isPersisted()) {
            mPilotingItf.publish();
        }
    }

    @Override
    public final void requestActivation() {
        super.requestActivation();
        if (mRestart && mPilotingItf.isPaused()) {
            sendCommand(ArsdkFeatureCommon.Mavlink.encodeStop());
        } else {
            mRestart = false;
            sendStart();
        }
    }

    @Override
    public final void requestDeactivation() {
        super.requestDeactivation();
        sendCommand(ArsdkFeatureCommon.Mavlink.encodePause());
    }

    @Override
    @NonNull
    public final FlightPlanPilotingItfCore getPilotingItf() {
        return mPilotingItf;
    }

    @Override
    protected final void onConnected() {
        super.onConnected();
        applyPresets();
        mPilotingItf.publish();
    }

    @Override
    protected final void onDisconnected() {
        mRestart = false;
        mPlaying = false;
        mStopped = false;

        mPilotingItf.cancelSettingsRollbacks()
                    .resetUnavailabilityReasons()
                    .updateActivationError(ActivationError.NONE)
                    .updateUploadState(UploadState.NONE)
                    .updateFlightPlanKnown(false)
                    .updatePaused(false)
                    .updateMissionItemExecuted(-1);

        if (!isPersisted()) {
            mPilotingItf.unpublish();
        }
        super.onDisconnected();
    }

    @Override
    protected final void onPresetChange() {
        mPresetDict = mDeviceController.getPresetDict().getDictionary(SETTINGS_KEY);
        if (isConnected()) {
            applyPresets();
        }
        mPilotingItf.notifyUpdated();
    }

    @Override
    protected final void onForgetting() {
        if (mDeviceDict != null) {
            mDeviceDict.clear().commit();
        }
        mPilotingItf.unpublish();
    }

    @Override
    protected final void onCommandReceived(@NonNull ArsdkCommand command) {
        int featureId = command.getFeatureId();
        if (featureId == ArsdkFeatureCommon.FlightPlanState.UID) {
            ArsdkFeatureCommon.FlightPlanState.decode(command, mFlightPlanStateCallback);
        } else if (featureId == ArsdkFeatureCommon.MavlinkState.UID) {
            ArsdkFeatureCommon.MavlinkState.decode(command, mMavlinkStateCallback);
        } else if (featureId == ArsdkFeatureCommon.FlightPlanSettingsState.UID) {
            ArsdkFeatureCommon.FlightPlanSettingsState.decode(command, mFlightPlanSettingStateCallback);
        }
    }

    /**
     * Requests the device to start executing the flight plan.
     */
    private void sendStart() {
        sendCommand(ArsdkFeatureCommon.Mavlink.encodeStart(mFlightPlanUid,
                ArsdkFeatureCommon.MavlinkStartType.FLIGHTPLAN));
    }

    /**
     * Sends selected return home on disconnect state to the device.
     *
     * @param enabled {@code true} to enable return home on disconnect, {@code false} to disable it
     *
     * @return {@code true} if any command was sent to the device, otherwise false
     */
    private boolean sendReturnHomeOnDisconnect(boolean enabled) {
        return sendCommand(ArsdkFeatureCommon.FlightPlanSettings.encodeReturnHomeOnDisconnect(enabled ? 1 : 0));
    }

    /**
     * Called back by subclasses to notify reception of return home on disconnect mutability from the device.
     * <p>
     * Persists the given value in the device specific settings store and updates the component's setting accordingly.
     * <p>
     * Note that this method does not call {@link FlightPlanPilotingItfCore#notifyUpdated()}.
     *
     * @param value received device value
     */
    private void onReturnHomeOnDisconnectMutability(boolean value) {
        RETURN_HOME_ON_DISCONNECT_MUTABILITY_SETTING.save(mDeviceDict, value);
        mPilotingItf.getReturnHomeOnDisconnect()
                    .updateMutableFlag(value);
    }

    /**
     * Called back by subclasses to notify reception of return home on disconnect state from the device.
     * <p>
     * Updates the controller's current local value, and in case the device is connected, updates the component's
     * setting accordingly.
     * <p>
     * Note that this method does not call {@link FlightPlanPilotingItfCore#notifyUpdated()}.
     *
     * @param value received device value
     */
    private void onReturnHomeOnDisconnect(boolean value) {
        mReturnHomeOnDisconnect = value;
        if (isConnected()) {
            mPilotingItf.getReturnHomeOnDisconnect()
                        .updateEnabledFlag(value);
        }
    }

    /**
     * Tells whether device specific settings are persisted for this component.
     *
     * @return {@code true} if the component has persisted device settings, otherwise {@code false}
     */
    private boolean isPersisted() {
        return mDeviceDict != null && !mDeviceDict.isNew();
    }

    /**
     * Loads presets and settings from persistent storage and updates the component accordingly.
     */
    private void loadPersistedData() {
        mPilotingItf.getReturnHomeOnDisconnect().updateMutableFlag(
                Boolean.TRUE.equals(RETURN_HOME_ON_DISCONNECT_MUTABILITY_SETTING.load(mDeviceDict)));

        applyPresets();
    }

    /**
     * Applies component's persisted presets.
     */
    private void applyPresets() {
        applyReturnHomeOnDisconnect(RETURN_HOME_ON_DISCONNECT_PRESET.load(mPresetDict));
    }

    /**
     * Applies return home on disconnect.
     * <ul>
     * <li>Finds an appropriate fallback value if the given value is null, or unsupported;</li>
     * <li>Sends the computed value to the drone in case it differs from the last received value;</li>
     * <li>Updates the component's setting accordingly.</li>
     * </ul>
     *
     * @param returnHomeOnDisconnect value to apply
     *
     * @return {@code true} if a command was sent to the device and the component's setting should arm its updating
     *         flag
     */
    private boolean applyReturnHomeOnDisconnect(@Nullable Boolean returnHomeOnDisconnect) {
        if (returnHomeOnDisconnect == null) {
            if (mReturnHomeOnDisconnect == null) {
                return false;
            }
            returnHomeOnDisconnect = mReturnHomeOnDisconnect;
        }

        boolean updating = !returnHomeOnDisconnect.equals(mReturnHomeOnDisconnect)
                           && sendReturnHomeOnDisconnect(returnHomeOnDisconnect);

        mReturnHomeOnDisconnect = returnHomeOnDisconnect;
        mPilotingItf.getReturnHomeOnDisconnect()
                    .updateEnabledFlag(returnHomeOnDisconnect);

        return updating;
    }

    /**
     * Updates unavailability reasons with missing flight plan state.
     */
    private void updateMissingFileReason() {
        if (mFlightPlanUid == null && !mPlaying) {
            mPilotingItf.addUnavailabilityReason(UnavailabilityReason.MISSING_FLIGHT_PLAN_FILE);
        } else {
            mPilotingItf.removeUnavailabilityReason(UnavailabilityReason.MISSING_FLIGHT_PLAN_FILE);
        }
    }

    /**
     * Computes and notify piloting interface availability.
     */
    private void updateAvailability() {
        if (!mPlaying) {
            if ((mFlightPlanUid != null || mFlightPlanToUpload != null) && mFlightPlanAvailable) {
                notifyIdle();
            } else {
                notifyUnavailable();
            }
        }
    }

    /** Callbacks called when a command of the feature ArsdkFeatureCommon.FlightPlanState is decoded. */
    private final ArsdkFeatureCommon.FlightPlanState.Callback mFlightPlanStateCallback =
            new ArsdkFeatureCommon.FlightPlanState.Callback() {

                @Override
                public void onAvailabilityStateChanged(int availabilityState) {
                    if (ULog.d(TAG_FLIGHTPLAN)) {
                        ULog.d(TAG_FLIGHTPLAN, "onAvailabilityStateChanged [state: " + availabilityState + "]");
                    }
                    mFlightPlanAvailable = availabilityState == 1;
                    if (mFlightPlanAvailable) {
                        mPilotingItf.resetUnavailabilityReasons();
                        updateMissingFileReason();
                    }
                    updateAvailability();
                }

                @Override
                public void onComponentStateListChanged(
                        @Nullable ArsdkFeatureCommon.FlightplanstateComponentstatelistchangedComponent component,
                        int state) {
                    if (ULog.d(TAG_FLIGHTPLAN)) {
                        ULog.d(TAG_FLIGHTPLAN, "onComponentStateListChanged [component: " + component
                                               + ", state: " + state + "]");
                    }

                    if (component != null) {
                        UnavailabilityReason reason = null;
                        ActivationError error = null;
                        switch (component) {
                            case GPS:
                                reason = UnavailabilityReason.DRONE_GPS_INFO_INACCURATE;
                                break;
                            case CALIBRATION:
                                reason = UnavailabilityReason.DRONE_NOT_CALIBRATED;
                                break;
                            case MAVLINK_FILE:
                                error = ActivationError.INCORRECT_FLIGHT_PLAN_FILE;
                                break;
                            case TAKEOFF:
                                reason = UnavailabilityReason.CANNOT_TAKE_OFF;
                                break;
                            case WAYPOINTSBEYONDGEOFENCE:
                                error = ActivationError.WAYPOINT_BEYOND_GEOFENCE;
                                break;
                            case CAMERAAVAILABLE:
                                reason = UnavailabilityReason.CAMERA_UNAVAILABLE;
                                break;
                        }
                        if (reason != null) {
                            if (state == 0) {
                                mPilotingItf.addUnavailabilityReason(reason);
                            } else {
                                mPilotingItf.removeUnavailabilityReason(reason);
                            }
                        }
                        if (error != null) {
                            if (state == 0) {
                                mPilotingItf.updateActivationError(error);
                            } else {
                                mPilotingItf.clearActivationError(error);
                            }
                        }
                        mPilotingItf.notifyUpdated();
                    }
                }
            };

    /** Callbacks called when a command of the feature ArsdkFeatureCommon.MavlinkState is decoded. */
    private final ArsdkFeatureCommon.MavlinkState.Callback mMavlinkStateCallback =
            new ArsdkFeatureCommon.MavlinkState.Callback() {

                @Override
                public void onMavlinkFilePlayingStateChanged(
                        @Nullable MavlinkstateMavlinkfileplayingstatechangedState state,
                        String filepath,
                        @Nullable MavlinkstateMavlinkfileplayingstatechangedType type) {
                    if (ULog.d(TAG_FLIGHTPLAN)) {
                        ULog.d(TAG_FLIGHTPLAN, "onMavlinkFilePlayingStateChanged [state: " + state
                                               + ", file: " + filepath + ", type: " + type + "]");
                    }

                    mPlaying = state == MavlinkstateMavlinkfileplayingstatechangedState.PLAYING;
                    if (filepath == null || mFlightPlanUid == null || !filepath.endsWith(mFlightPlanUid)) {
                        mFlightPlanUid = null;
                    }
                    mPilotingItf.updateFlightPlanKnown(mFlightPlanUid != null);
                    updateMissingFileReason();

                    if (state != null) {
                        switch (state) {
                            case PLAYING:
                                if (mStopped) {
                                    mStopped = false;
                                    mPilotingItf.updateMissionItemExecuted(-1);
                                }
                                mPilotingItf.updatePaused(false);
                                notifyActive();
                                break;
                            case STOPPED:
                                mStopped = true;
                                // only change pause state if there is no flight plan waiting for upload
                                if (mFlightPlanToUpload == null) {
                                    mPilotingItf.updatePaused(false);
                                }

                                if (mRestart) {
                                    mRestart = false;
                                    sendStart();
                                }

                                updateAvailability(); // since mPlaying == false, this will always notifyUpdated()

                                // upload pending flight plan if any
                                if (mFlightPlanToUpload != null) {
                                    uploadFlightPlan(mFlightPlanToUpload);
                                }
                                break;
                            case PAUSED:
                                mStopped = false;
                                // only change pause state if there is no flight plan waiting for upload
                                if (mFlightPlanToUpload == null) {
                                    mPilotingItf.updatePaused(mFlightPlanUid != null);
                                }

                                updateAvailability();

                                // upload pending flight plan if any
                                if (mFlightPlanToUpload != null) {
                                    uploadFlightPlan(mFlightPlanToUpload);
                                }
                                break;
                            case LOADED:
                                // Only for Disco, ignoring
                                break;
                        }
                    }
                }

                @Override
                public void onMissionItemExecuted(long idx) {
                    if (ULog.d(TAG_FLIGHTPLAN)) {
                        ULog.d(TAG_FLIGHTPLAN, "onMissionItemExecuted [idx: " + idx + "]");
                    }

                    if (mPilotingItf.getLatestUploadState() != UploadState.UPLOADING) {
                        mPilotingItf.updateMissionItemExecuted((int) idx).notifyUpdated();
                    }
                }
            };

    /**
     * Uploads a flight plan to the drone.
     *
     * @param flightPlan flight plan file to upload
     */
    private void uploadFlightPlan(@NonNull File flightPlan) {
        mPilotingItf.updateUploadState(UploadState.UPLOADING)
                    .updateMissionItemExecuted(-1)
                    .notifyUpdated();
        if (mStopped) {
            mFlightPlanToUpload = null;
            HttpFlightPlanClient client = mDeviceController.getHttpClient(HttpFlightPlanClient.class);
            if (client == null) {
                // Invalid state, drone not connected
                return;
            }
            client.uploadFlightPlan(flightPlan, (status, code, flightPlanUid) -> {
                boolean success = status == HttpRequest.Status.SUCCESS;
                if (ULog.d(TAG_FLIGHTPLAN)) {
                    ULog.d(TAG_FLIGHTPLAN, "uploadFlightPlan complete [success: " + success
                                           + ", uid: " + flightPlanUid + "]");
                }
                mFlightPlanUid = success ? flightPlanUid : null;
                mPilotingItf.updateUploadState(success ? UploadState.UPLOADED : UploadState.FAILED)
                            .updateFlightPlanKnown(mFlightPlanUid != null)
                            .updatePaused(false);
                updateMissingFileReason();
                if (canDeactivate()) { // pause flight plan if necessary
                    requestDeactivation();
                } else {
                    updateAvailability();
                }
                mPilotingItf.notifyUpdated();
            });
        } else {
            // stop current flight plan, if any, before uploading the file
            mFlightPlanToUpload = flightPlan;
            sendCommand(ArsdkFeatureCommon.Mavlink.encodeStop());
        }
    }

    /** Callbacks called when a command of the feature ArsdkFeatureCommon.FlightPlanSettingsState is decoded. */
    private final ArsdkFeatureCommon.FlightPlanSettingsState.Callback mFlightPlanSettingStateCallback =
            new ArsdkFeatureCommon.FlightPlanSettingsState.Callback() {

                @Override
                public void onReturnHomeOnDisconnectChanged(int state, int isReadOnly) {
                    if (ULog.d(TAG_FLIGHTPLAN)) {
                        ULog.d(TAG_FLIGHTPLAN, "onReturnHomeOnDisconnectChanged [state: " + state
                                               + ", read-only: " + isReadOnly + "]");
                    }
                    onReturnHomeOnDisconnectMutability(isReadOnly == 0);
                    onReturnHomeOnDisconnect(state == 1);
                    mPilotingItf.notifyUpdated();
                }
            };

    /** Backend of FlightPlanPilotingItfCore implementation. */
    private final class Backend extends ActivablePilotingItfController.Backend
            implements FlightPlanPilotingItfCore.Backend {

        @Override
        public void uploadFlightPlan(@NonNull File flightPlan) {
            AnafiFlightPlanPilotingItf.this.uploadFlightPlan(flightPlan);
        }

        @Override
        public boolean activate(boolean restart) {
            mRestart = restart;
            mPilotingItf.updateActivationError(ActivationError.NONE).notifyUpdated();
            return activate();
        }

        @Override
        public boolean setReturnHomeOnDisconnect(boolean enable) {
            boolean updating = applyReturnHomeOnDisconnect(enable);
            RETURN_HOME_ON_DISCONNECT_PRESET.save(mPresetDict, enable);
            if (!updating) {
                mPilotingItf.notifyUpdated();
            }
            return updating;
        }
    }
}
